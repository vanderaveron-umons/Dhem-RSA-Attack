import unittest
import subprocess
import shutil
import re
# Import the classes from your implementation using the new package structure
from rsa_key_generator import RSAKeyGenerator, RSAKeyPair, RSAPublicKey

# Import the necessary components from the 'cryptography' library
# You may need to install it: pip install cryptography
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization


def is_openssl_available():
    """Check if the 'openssl' command is available in the system's PATH."""
    return shutil.which("openssl") is not None


@unittest.skipIf(not is_openssl_available(), "openssl command not found, skipping command-line tests.")
class TestOpenSSLInterop(unittest.TestCase):
    """
    Tests for command-line interoperability with the OpenSSL tool.
    These tests are skipped if 'openssl' is not installed.
    """

    def test_interop_export_to_openssl(self):
        """
        Tests if openssl can read a private key generated by our code.
        """
        print("\n--- Running Test: Interop - Export to openssl ---")
        # 1. Generate a key with our code
        our_keypair = RSAKeyGenerator.generate_keypair(key_length=1024)
        private_pem_str = our_keypair.export_private_pem()

        # 2. Pipe the PEM to openssl to validate its format.
        # We remove "-in -" as some versions (like LibreSSL on macOS) fail on it,
        # and reading from stdin is the default anyway.
        process = subprocess.run(
            ["openssl", "rsa", "-text", "-noout"],
            input=private_pem_str.encode('utf-8'),
            capture_output=True,
            check=False  # We check the return code manually
        )

        # 3. Check if openssl processed it successfully
        self.assertEqual(process.returncode, 0, f"openssl failed to parse our key. Stderr: {process.stderr.decode()}")
        print("  Export to openssl test PASSED.")

    def test_interop_import_from_openssl(self):
        """
        Tests if our code can correctly import a key generated by openssl.
        """
        print("\n--- Running Test: Interop - Import from openssl ---")
        # 1. Generate a key using the openssl command line
        process = subprocess.run(
            ["openssl", "genrsa", "1024"],
            capture_output=True,
            check=True  # Fails if openssl command has an error
        )
        openssl_pem_str = process.stdout.decode('utf-8')

        # 2. Import the key using our code
        imported_keypair = RSAKeyPair.from_pem_private(openssl_pem_str)

        # 3. Use openssl to dump the key components for verification.
        # We remove "-in -" for better portability (especially with LibreSSL on macOS).
        dump_process = subprocess.run(
            ["openssl", "rsa", "-text", "-noout"],
            input=openssl_pem_str.encode('utf-8'),
            capture_output=True,
            check=True
        )
        openssl_dump = dump_process.stdout.decode('utf-8')

        # 4. Parse the numbers from the openssl text dump
        def parse_openssl_hex(name, text_dump):
            # Regex to find a named block of hex values and clean them up
            match = re.search(fr"{name}:\s*\n\s+((?:[0-9a-f]{{2}}:\s*)+[0-9a-f]{{2}})", text_dump, re.MULTILINE)
            self.assertIsNotNone(match, f"Could not parse '{name}' from openssl output")
            hex_str = re.sub(r'[:\s]', '', match.group(1))
            return int(hex_str, 16)

        n = parse_openssl_hex("modulus", openssl_dump)
        e = int(re.search(r"publicExponent: (\d+)", openssl_dump).group(1))
        d = parse_openssl_hex("privateExponent", openssl_dump)
        p = parse_openssl_hex("prime1", openssl_dump)
        q = parse_openssl_hex("prime2", openssl_dump)

        # 5. Assert that our imported values match the openssl values
        self.assertEqual(imported_keypair.private_key.n, n)
        self.assertEqual(imported_keypair.public_key.e, e)
        self.assertEqual(imported_keypair.private_key.d, d)
        self.assertEqual(imported_keypair.private_key.p, p)
        self.assertEqual(imported_keypair.private_key.q, q)
        print("  Import from openssl test PASSED.")


class TestRSAKeyGenerationAndPEM(unittest.TestCase):
    """
    A comprehensive test suite for the RSA key generator and its PEM
    import/export functionality. It tests internal consistency and
    interoperability with the standard 'cryptography' library.
    """

    def test_internal_roundtrip(self):
        """
        Tests the full internal cycle: generate -> export -> import.
        Ensures that the re-imported key is identical to the original.
        """
        print("\n--- Running Test: Internal Round-trip ---")

        # Test with a standard key size and a small, non-default public exponent
        test_configs = [
            {'key_size': 512, 'public_exponent': 65537},
            {'key_size': 256, 'public_exponent': 3}  # Small key for speed, different e
        ]

        for config in test_configs:
            with self.subTest(config=config):
                print(f"  Testing with config: {config}")
                # 1. Generate a key pair using our implementation
                original_keypair = RSAKeyGenerator.generate_keypair(
                    key_length=config['key_size'],
                    public_exponent=config['public_exponent']
                )

                # 2. Export both private and public keys to PEM format
                private_pem = original_keypair.export_private_pem()
                public_pem = original_keypair.export_public_pem()

                self.assertIn("-----BEGIN RSA PRIVATE KEY-----", private_pem)
                self.assertIn("-----BEGIN RSA PUBLIC KEY-----", public_pem)

                # 3. Import the keys back from the PEM strings
                imported_keypair = RSAKeyPair.from_pem_private(private_pem)

                # We can't directly create a public key from PEM in the current structure,
                # but the private PEM import already reconstructs the full pair.

                # 4. Assert that all components of the imported key match the original
                self.assertEqual(original_keypair.private_key.n, imported_keypair.private_key.n)
                self.assertEqual(original_keypair.private_key.d, imported_keypair.private_key.d)
                self.assertEqual(original_keypair.private_key.p, imported_keypair.private_key.p)
                self.assertEqual(original_keypair.private_key.q, imported_keypair.private_key.q)
                self.assertEqual(original_keypair.public_key.e, imported_keypair.public_key.e)
        print("  Internal round-trip test PASSED.")

    def test_interop_import_from_cryptography_lib(self):
        """
        Tests if our code can correctly import keys generated by the standard
        'cryptography' library.
        """
        print("\n--- Running Test: Interop - Import from 'cryptography' ---")

        # 1. Generate a key using the 'cryptography' library.
        # NOTE: This library enforces a minimum key size of 1024 bits for security.
        crypto_private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=1024,
        )
        crypto_numbers = crypto_private_key.private_numbers()

        # 2. Export the key to PKCS#1 PEM format (what our code expects)
        private_pem_bytes = crypto_private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,  # Corrected from PKCS1
            encryption_algorithm=serialization.NoEncryption()
        )
        private_pem_str = private_pem_bytes.decode('utf-8')

        # 3. Import the PEM using our implementation
        imported_keypair = RSAKeyPair.from_pem_private(private_pem_str)

        # 4. Assert that our imported key's numbers match the original numbers
        # The modulus (n) and public exponent (e) are in a nested public_numbers object.
        self.assertEqual(imported_keypair.private_key.n, crypto_numbers.public_numbers.n)
        self.assertEqual(imported_keypair.public_key.e, crypto_numbers.public_numbers.e)
        self.assertEqual(imported_keypair.private_key.d, crypto_numbers.d)
        self.assertEqual(imported_keypair.private_key.p, crypto_numbers.p)
        self.assertEqual(imported_keypair.private_key.q, crypto_numbers.q)
        print("  Import from 'cryptography' test PASSED.")

    def test_interop_export_to_cryptography_lib(self):
        """
        Tests if the 'cryptography' library can correctly import keys
        generated and exported by our code.
        """
        print("\n--- Running Test: Interop - Export to 'cryptography' ---")

        # 1. Generate a key pair using our implementation, with a size
        # compatible with the 'cryptography' library's standards.
        our_keypair = RSAKeyGenerator.generate_keypair(key_length=1024)

        # 2. Export the private key to PEM format
        private_pem_str = our_keypair.export_private_pem()
        private_pem_bytes = private_pem_str.encode('utf-8')

        # 3. Import the PEM using the 'cryptography' library
        try:
            crypto_imported_key = serialization.load_pem_private_key(
                private_pem_bytes,
                password=None
            )
            crypto_numbers = crypto_imported_key.private_numbers()
        except Exception as e:
            self.fail(f"Cryptography library failed to import our PEM key: {e}")

        # 4. Assert that the imported key's numbers match our original numbers
        # The modulus (n) and public exponent (e) are in a nested public_numbers object.
        self.assertEqual(crypto_numbers.public_numbers.n, our_keypair.private_key.n)
        self.assertEqual(crypto_numbers.public_numbers.e, our_keypair.public_key.e)
        self.assertEqual(crypto_numbers.d, our_keypair.private_key.d)
        self.assertEqual(crypto_numbers.p, our_keypair.private_key.p)
        self.assertEqual(crypto_numbers.q, our_keypair.private_key.q)
        print("  Export to 'cryptography' test PASSED.")


if __name__ == '__main__':
    # This allows the test to be run from the command line
    unittest.main()
